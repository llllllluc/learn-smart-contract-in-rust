/**
* This file was automatically generated by @octalmage/terra-cosmwasm-typescript-gen@0.2.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @octalmage/terra-cosmwasm-typescript-gen generate command to regenerate this file.
*/

import { LCDClient, Coins, Wallet, MsgExecuteContract, TxInfo, WaitTxBroadcastResult } from "@terra-money/terra.js";
import { ConnectedWallet } from "@terra-money/wallet-provider";
function isConnectedWallet(x: Wallet | ConnectedWallet): x is ConnectedWallet {
  return typeof (x as Wallet).key === "undefined";
};
async function waitForInclusionInBlock(lcd: LCDClient, txHash: string): Promise<TxInfo | undefined> {
  let res;
  for (let i = 0; i <= 50; i++) {
    try {
      res = await lcd.tx.txInfo(txHash);
    } catch (error) {
      // NOOP
    }
      
    if (res) {
      break;
    }
      
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
      
  return res;
};
export type ExecuteMsg = {
  deposit: DepositType;
} | {
  burn: {
    amount: Uint128;
    token_address: string;
    [k: string]: unknown;
  };
};
export type DepositType = {
  instantiate: InstantiateMsg;
} | {
  mint: {
    recipient: string;
    token_address: string;
    [k: string]: unknown;
  };
};
export type Uint128 = string;
export type Logo = {
  url: string;
} | {
  embedded: EmbeddedLogo;
};
export type EmbeddedLogo = {
  svg: Binary;
} | {
  png: Binary;
};
export type Binary = string;
export interface InstantiateMsg {
  stable_denom: string;
  token_contract_code_id: number;
  [k: string]: unknown;
}
export interface Cw20Coin {
  address: string;
  amount: Uint128;
  [k: string]: unknown;
}
export interface InstantiateMarketingInfo {
  description?: string | null;
  logo?: Logo | null;
  marketing?: string | null;
  project?: string | null;
  [k: string]: unknown;
}
export interface MinterResponse {
  cap?: Uint128 | null;
  minter: string;
  [k: string]: unknown;
}
export type QueryMsg = {
  get_minted_tokens: {
    [k: string]: unknown;
  };
};
export interface TokenFactoryReadOnlyInterface {
  contractAddress: string;
  getMintedTokensQuery: () => Promise<MintedTokensResponse>;
}
export class TokenFactoryQueryClient implements TokenFactoryReadOnlyInterface {
  client: LCDClient;
  contractAddress: string;

  constructor(client: LCDClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getMintedTokensQuery = this.getMintedTokensQuery.bind(this);
  }

  getMintedTokensQuery = async (): Promise<MintedTokensResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      get_minted_tokens: {}
    });
  };
}
export interface TokenFactoryInterface extends TokenFactoryReadOnlyInterface {
  contractAddress: string;
  deposit: (funds?: Coins) => Promise<any>;
  burn: ({
    amount,
    tokenAddress
  }: {
    amount: string;
    tokenAddress: string;
  }, funds?: Coins) => Promise<any>;
}
export class TokenFactoryClient extends TokenFactoryQueryClient implements TokenFactoryInterface {
  client: LCDClient;
  wallet: Wallet | ConnectedWallet;
  contractAddress: string;

  constructor(client: LCDClient, wallet: Wallet | ConnectedWallet, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.wallet = wallet;
    this.contractAddress = contractAddress;
    this.deposit = this.deposit.bind(this);
    this.burn = this.burn.bind(this);
  }

  deposit = async (funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      deposit: {}
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
  burn = async ({
    amount,
    tokenAddress
  }: {
    amount: string;
    tokenAddress: string;
  }, funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      burn: {
        amount,
        token_address: tokenAddress
      }
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
}